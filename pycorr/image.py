import cv2
import numpy as np
import pycorr_extensions as cpp

class Image:
    """Image class for pycorr.
    
    Parameters
    ----------
    filepath : str
        Path to image.
    border : int
        Bi-quintic B-spline interpolation border.
        
    Attributes
    ----------
    image : `numpy.ndarray` (Nx, Ny, 3)
        3D array containing three colour channels of image data of type `int`, loaded by OpenCV function :py:func:`~cv2.imread`.
    image_gs : `numpy.ndarray` (Nx, Ny)
        2D array containing grayscale image data of type `int`, generated by OpenCV function :py:func:`~cv2.cvtColor`.
    C : numpy.ndarray `numpy.ndarray` (Nx+(2*border), Ny+(2*border))
        2D array containing B-spline coefficieints of type `float`, computed by :meth:`~_get_C`.
    QK_C_QKT : `numpy.ndarray` (6*Nx, 6*Ny)
        2D array containing precomputed bi-quintic B-spline interpolation matrices of type `float`, computed by :meth:`~_get_QK_C_QKT`.
    """
    def __init__(self, filepath, border=20):
        """Initialisation of pycorr image object."""
        self.filepath = filepath
        self.border = np.int_(border)
        self._get_image()
        self._get_image_gs()
        self._get_C()
        self._get_QK_C_QKT()
        
    def _get_image(self):
        """Private method to load image using OpenCV function 'imread'."""
        self.image = cv2.imread(self.filepath, cv2.IMREAD_COLOR)
        return
    
    def _get_image_gs(self):
        """Private method to convert colour image to grayscale image for image processing purposes using OpenCV function 'cvtColor'."""
        self.image_gs = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        return
        
    def _get_C(self):
        r"""Private method to calculate the bi-quintic B-spline coefficient matrix :math:`\mathbf{C}` for image intensity interpolation. The method calculates the B-spline coefficents using 1D deconvolution.
        
        The grayscale image :math:`\mathbf{I}`, is first padded with a replicated border (default of 20 pixels) to create the padded image :math:`\mathbf{I}_{p}`. 
        Next the quintic B-spline kernel :math:`\mathbf{b}`:
            
        .. math::
            
           \mathbf{b} = \begin{bmatrix} 1/120 &  13/60 & 11/20 & 13/60 & 1/120 & 0 \end{bmatrix}
        
        A null vector :math:`\mathbf{b}_{x(m)} = [0]` is then created, into which the B-spline kernal is inserted as follows:
            
        .. math::
            
            \mathbf{b}_{x \left( 0:3 \right)} = \mathbf{b}_{\left( 3:5 \right)} \text{ and } \mathbf{b}_{x \left( 3:5 \right)} = \mathbf{b}_{\left( 0:3 \right)}
           
        The Fast Fourier Transform (FFT) of this padded kernel vector is used to divide the FFT of the :math:`i`-th row of the padded grayscale image :math:`\mathbf{I}_{p}`, after which the inverse FFT is taken for each row:
            
        .. math::
            
            \mathbf{C}_{\left( i, : \right)} = F^{-1}\left[ \frac{ F\left[ \mathbf{I}_{p\left( i, : \right)} \right] }{ F\left[ \mathbf{b}_{x} \right] } \right]
            
        where :math:`F` and :math:`F^{-1}` represent the FFT and inverse FFT, respectively. \
            
        A second null vector :math:`\mathbf{b}_{y(n)} = [0]` is then created, into which the B-spline kernal is inserted as follows:
        
        .. math::
            
           \mathbf{b}_{y \left( 0:3 \right)} = \mathbf{b}_{\left( 3:5 \right)} \text{ and } \mathbf{b}_{y \left( 3:5 \right)} = \mathbf{b}_{\left( 0:3 \right)}
           
        The FFT of this padded kernel vector is used to divide the FFT of the :math:`j`-th column of the B-spline coefficient matrix :math:`\mathbf{C}`,
        after which the inverse FFT is taken for each column to yield the final matrix of B-spline coefficients:
        
        .. math::
            
            \mathbf{C}_{\left( :, j \right)} = F^{-1}\left[ \frac{ F\left[ \mathbf{C}_{\left( :, j \right)} \right] }{ F\left[ \mathbf{b}_{y} \right] } \right]
            
        .. warning::
            
            The padded image must be at least as large as the quintic B-spline kernel in order for this method to function correctly (i.e. i > 5, j > 5). 
        """
        image_gs_pad = cv2.copyMakeBorder(self.image_gs, self.border, self.border, self.border, self.border, cv2.BORDER_REPLICATE)

        kernel = np.array([1/120, 13/60, 11/20, 13/60, 1/120, 0], order='F')

        # Python version.
        C = np.zeros((np.shape(image_gs_pad)[0],np.shape(image_gs_pad)[1]), dtype=complex, order='F')

        # Work through rows first.
        # Setup kernel vector.
        kernel_x = np.zeros((np.shape(image_gs_pad)[1]), dtype=complex)
        kernel_x[0:3] = kernel[3:]
        kernel_x[-3:] = kernel[0:3]
        kernel_x = np.fft.fft(kernel_x)

        # FFT across rows.
        for i in np.arange(0, np.shape(image_gs_pad)[0], 1):
            C[i, :] = np.fft.ifft(np.fft.fft(image_gs_pad[i, :])/kernel_x)

        # Now work through columns.
        # Setup kernel vector.
        kernel_y = np.zeros((np.shape(image_gs_pad)[0]), dtype=complex)
        kernel_y[0:3] = kernel[3:]
        kernel_y[-3:] = kernel[0:3]
        kernel_y = np.fft.fft(kernel_y)

        # FFT along columns.
        for j in np.arange(0, np.shape(image_gs_pad)[1], 1):
            C[:, j] = np.fft.ifft(np.fft.fft(C[:, j])/kernel_y)

        # Discard the imaginary part.
        self.C = np.real(C)

        return
    
    def _get_QK_C_QKT(self):
        r"""Private method to pre-calculate :math:`\mathbf{QK} \cdot \mathbf{C}_\left(i-2:i+3, j-2:j+3\right) \cdot \mathbf{QK^T}` matrix for the image for use in the bi-quintic B-spline image intensity interpolation process.
        
        The bi-quintic B-spline kernel :math:`\mathbf{QK}` is:
        
        .. math::
            
           \mathbf{QK} = \begin{bmatrix}
                           1/120 &  13/60 & 11/20 & 13/60 & 1/120 &     0 \\
                           -1/24 &  -5/12 &      0 &  5/12 &  1/24 &     0 \\
                            1/12 &    1/6 &   -1/2 &   1/6 &  1/12 &     0 \\
                           -1/12 &    1/6 &      0 &  -1/6 &  1/12 &     0 \\
                            1/24 &   -1/6 &    1/4 &  -1/6 &  1/24 &     0 \\
                          -1/120 &   1/24 &  -1/12 & -1/12 & -1/24 & 1/120 
                         \end{bmatrix} 
                         
        and :math:`\mathbf{QK^{T}}` is its transpose. 
        
        The :math:`\mathbf{C}_\left(i-2:i+3, j-2:j+3\right)` matrix is a subset of the B-spline coefficient matrix :math:`\mathbf{C}` computed by :py:meth:`pycorr.Image._get_C`, where :math:`i` and :math:`j` are the image coordinates:
            
        .. math::
            
           \mathbf{C}_\left(i-2:i+3, j-2:j+3\right) = \begin{bmatrix}
                          \mathbf{C}_\left(i-2,j-2 \right) &  \mathbf{C}_\left(i-1,j-2 \right) & \mathbf{C}_\left(i,j-2 \right) & \mathbf{C}_\left(i+1,j-2 \right) & \mathbf{C}_\left(i+2,j-2 \right) & \mathbf{C}_\left(i+3,j-2 \right) \\
                          \mathbf{C}_\left(i-2,j-1 \right) &  \mathbf{C}_\left(i-1,j-1 \right) & \mathbf{C}_\left(i,j-1 \right) & \mathbf{C}_\left(i+1,j-1 \right) & \mathbf{C}_\left(i+2,j-1 \right) & \mathbf{C}_\left(i+3,j-1 \right) \\
                          \mathbf{C}_\left(i-2,j \right)   &  \mathbf{C}_\left(i-1,j \right)   & \mathbf{C}_\left(i,j \right)   & \mathbf{C}_\left(i+1,j \right)   & \mathbf{C}_\left(i+2,j \right)   & \mathbf{C}_\left(i+3,j \right)   \\
                          \mathbf{C}_\left(i-2,j+1 \right) &  \mathbf{C}_\left(i-1,j+1 \right) & \mathbf{C}_\left(i,j+1 \right) & \mathbf{C}_\left(i+1,j+1 \right) & \mathbf{C}_\left(i+2,j+1 \right) & \mathbf{C}_\left(i+3,j+1 \right) \\
                          \mathbf{C}_\left(i-2,j+2 \right) &  \mathbf{C}_\left(i-1,j+2 \right) & \mathbf{C}_\left(i,j+2 \right) & \mathbf{C}_\left(i+1,j+2 \right) & \mathbf{C}_\left(i+2,j+2 \right) & \mathbf{C}_\left(i+3,j+2 \right) \\
                          \mathbf{C}_\left(i-2,j+3 \right) &  \mathbf{C}_\left(i-1,j+3 \right) & \mathbf{C}_\left(i,j+3 \right) & \mathbf{C}_\left(i+1,j+3 \right) & \mathbf{C}_\left(i+2,j+3 \right) & \mathbf{C}_\left(i+3,j+3 \right) 
                        \end{bmatrix} 
                        
        .. note::
            
            This pre-computation - although computationally efficient when used in repeated image intensity interpolation - requires a significant amount of memory, particularly for large images.
        """
        QK = np.asarray(([ 1/120, 13/60, 11/20, 13/60, 1/120,     0],
                         [ -1/24, -5/12,     0,  5/12,  1/24,     0],
                         [  1/12,   1/6,  -1/2,   1/6,  1/12,     0],
                         [ -1/12,   1/6,     0,  -1/6,  1/12,     0],
                         [  1/24,  -1/6,   1/4,  -1/6,  1/24,     0],
                         [-1/120,  1/24, -1/12,  1/12, -1/24, 1/120]), np.float64, order='F')
        QKt = np.ascontiguousarray(np.transpose(QK), np.float64)
        self.QK_C_QKT = cpp.get_QK_C_QKT(QK, QKt, self.C, self.image_gs.shape, self.border)
        return



